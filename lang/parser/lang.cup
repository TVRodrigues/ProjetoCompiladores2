package lang.parser;

import java_cup.runtime.*;
import lang.ast.*;
import lang.ast.command.*;
import lang.ast.expr.*;
import lang.ast.types.*;
import java.util.ArrayList;
import java.util.List;

class LangParser;
parser code {:
// Conecta o parser ao lexer
LangLexer s;
public LangParser(LangLexer s){ this.s = s; }
// Obtém a linha atual
:}

init with {: :};
scan with {: return s.nextToken(); :};

/* Terminais */
terminal PLUS, MINUS, TIMES, DIV, MOD, LP, RP, LBRACE, RBRACE, LBRACKET, 
RBRACKET, MENORQ, MAIORQ, IGUAL, DIFERENTE, AND, NOT, ATTRIB, PV, COMMA, COLON, COLONCOLON, PRINT, DATA;
terminal IF, ELSE, ITERATE; // Adiciona o terminal ITERATE
terminal Integer NUMBER; 
terminal Boolean TRUE, FALSE;
terminal String ID;
terminal String TYID;
terminal Character CHAR;
terminal MAIN;
terminal RETURN;
terminal String STRING;
terminal NULL;
terminal Float FLOAT;
terminal String VOID;

/* Não terminais */
non terminal Exp expr;
non terminal Cmd cmd;
non terminal List<Cmd> cmds;
non terminal Cmd prog;
non terminal Cmd stmtBlock;
//non terminal List<Exp> exps;
non terminal LType type;
non terminal DataDecl dataDecl;
non terminal Decl decl;
non terminal List<Decl> decls;
non terminal Func func;
non terminal List<Func> funcs;
non terminal Param param;
non terminal List<Param> params;

/* Precedência e associatividade */
precedence left ID;
precedence left COMMA;
precedence left AND;
precedence left IGUAL, DIFERENTE;
precedence left MENORQ, MAIORQ;
precedence left PLUS, MINUS;
precedence left TIMES, DIV, MOD;
precedence right NOT;
precedence left ELSE;
precedence left IF;
precedence left PV;

/* Regras da gramática */

// Define o ponto de entrada para o programa principal
/*prog ::= MAIN LP RP LBRACE cmds:c RBRACE {: RESULT = new MainBlock(c); :}
      | MAIN LP RP COLON VOID LBRACE cmds:c RBRACE {: RESULT = new MainBlock(c); :}
      | error {: System.err.println("Erro de sintaxe!"); RESULT = null; :};*/

/*prog ::= dataDecls:data funcs:funcs MAIN LP RP LBRACE cmds:c RBRACE {:
            List<Cmd> allCmds = new ArrayList<>();
            allCmds.addAll(data);
            allCmds.addAll(funcs);
            allCmds.addAll(c);
            RESULT = new MainBlock(allCmds);
        :}
      | error {: 
            System.err.println("Erro de sintaxe!"); 
            RESULT = null; 
        :};*/

/*prog ::= dataDecls:data funcs:funcs MAIN LP RP LBRACE cmds:c RBRACE {:
            RESULT = new MainBlock(data, funcs, c);
        :}
        | error {: 
            System.err.println("Erro de sintaxe!"); 
            RESULT = null; 
        :};*/

prog ::= dataDecl:data funcs:funcs MAIN LP RP LBRACE cmds:c RBRACE {:
    List<DataDecl> dataList = new ArrayList<>();
    dataList.add(data);
    RESULT = new MainBlock(dataList, funcs, c);
:}
| funcs:funcs MAIN LP RP LBRACE cmds:c RBRACE {:
    RESULT = new MainBlock(new ArrayList<>(), funcs, c);
:}
| MAIN LP RP LBRACE cmds:c RBRACE {:
    RESULT = new MainBlock(new ArrayList<>(), new ArrayList<>(), c);
:}
        | error {: 
            System.err.println("Erro de sintaxe!"); 
            RESULT = null; 
        :};

dataDecl ::= DATA TYID:i LBRACE decls:ds RBRACE {:
    RESULT = new DataDecl(ileft, iright, i, ds);
:};

decls ::= decl:d {:
    List<Decl> list = new ArrayList<>();
    list.add(d);
    RESULT = list;
:}
| decls:ds decl:d {:
    ds.add(d);
    RESULT = ds;
:};

decl ::= ID:i COLONCOLON type:t PV {:
    RESULT = new Decl(ileft, iright, i, t);
:};


func ::= ID:i LP params:p RP COLON type:t stmtBlock:b {:
    RESULT = new Func(ileft, iright, i, p, t, List.of(b));
:}
| ID:i LP RP COLON type:t stmtBlock:b {:
    RESULT = new Func(ileft, iright, i, new ArrayList<>(), t, List.of(b));
:}
| ID:i LP params:p RP stmtBlock:b {:
    RESULT = new Func(ileft, iright, i, p, null, List.of(b));
:}
| ID:i LP RP stmtBlock:b {:
    RESULT = new Func(ileft, iright, i, new ArrayList<>(), null, List.of(b));
:};



funcs ::= func:f {: 
            List<Func> list = new ArrayList<>(); 
            list.add(f); 
            RESULT = list; 
          :}
        | funcs:fs func:f {: 
            fs.add(f); 
            RESULT = fs; 
          :};


params ::= param:p {:
    List<Param> list = new ArrayList<>();
    list.add(p);
    RESULT = list;
:}
| params:ps COMMA param:p {:
    ps.add(p);
    RESULT = ps;
:};

param ::= ID:i COLONCOLON type:t {:
    RESULT = new Param(ileft, iright, i, t);
:};

type ::= VOID:i {: RESULT = new TyVoid(ileft, iright); :}
      | CHAR:i {: RESULT = new TyChar(ileft, iright); :}
      | NUMBER:i {: RESULT = new TyInt(ileft, iright); :}
      | ID:i {: RESULT = new UserType(ileft, iright, i); :}
      | FLOAT:i {: RESULT = new TyFloat(ileft, iright); :}
      | TYID:i {: RESULT = new UserType(ileft, iright, i); :};

cmds ::= cmd:c PV {:
    List<Cmd> list = new ArrayList<>();
    list.add(c);
    RESULT = list;
:}
| cmds:cs cmd:c PV {:
    cs.add(c);
    RESULT = cs;
:};

// Define os comandos reconhecidos
cmd ::= ID:i ATTRIB expr:e {:
        RESULT = new Attrib(ileft, iright, new Var(ileft, iright, i), e);
      :}
    | IF LP expr:e RP stmtBlock:s {:
        RESULT = new IfCmd(e, s, null); 
      :}
    | IF LP expr:e RP stmtBlock:s1 ELSE stmtBlock:s2 {:
        RESULT = new IfCmd(e, s1, s2); 
      :}
    | ITERATE LP expr:e RP stmtBlock:s {:
        RESULT = new IterateCmd(e, s);
      :}
    | RETURN expr:e {: 
        RESULT = new ReturnExpr(e); 
      :}
    | PRINT expr:e {: 
        RESULT = new Print(e); 
      :};

stmtBlock ::= LBRACE cmds:cs RBRACE {:
                RESULT = new MainBlock(new ArrayList<>(), new ArrayList<>(), cs);
              :};

//exps ::= exps:es COMMA expr:e {:
//    es.add(e);
//    RESULT = es;
//:};

// Define as expressões
expr ::= expr:e1 PLUS:s expr:e2 {: RESULT = new Plus(sleft, sright, e1, e2); :}
      | expr:e1 MINUS:s expr:e2 {: RESULT = new Minus(sleft, sright, e1, e2); :}
      | expr:e1 TIMES:s expr:e2 {: RESULT = new Times(sleft, sright, e1, e2); :}
      | expr:e1 DIV:s expr:e2 {: RESULT = new Div(sleft, sright, e1, e2); :}
      | expr:e1 MOD:s expr:e2 {: RESULT = new Mod(sleft, sright, e1, e2); :}
      | expr:e1 MENORQ:s expr:e2 {: RESULT = new MenorQ(sleft, sright, e1, e2); :}
      | expr:e1 MAIORQ:s expr:e2 {: RESULT = new MaiorQ(sleft, sright, e1, e2); :}
      | expr:e1 IGUAL:s expr:e2 {: RESULT = new Igual(sleft, sright, e1, e2); :}
      | expr:e1 DIFERENTE:s expr:e2 {: RESULT = new Diferente(sleft, sright, e1, e2); :}
      | expr:e1 AND:s expr:e2 {: RESULT = new And(sleft, sright, e1, e2); :}
      | NOT:s expr:e {: RESULT = new Not(sleft, sright, e); :}
      | LP expr:e RP {: RESULT = e; :}
      | LBRACE expr:e RBRACE {: RESULT = e; :}
      | LBRACKET expr:e RBRACKET {: RESULT = e; :}
      | expr:e1 COMMA:s expr:e2 {: RESULT = new Comma(sleft, sright, e1, e2); :}
      | NUMBER:i {: RESULT = new IntLit(ileft, iright, i); :}
      | TRUE:i {: RESULT = new BoolLit(ileft, iright, i); :}
      | FALSE:i {: RESULT = new BoolLit(ileft, iright, i); :}
      | STRING:s {: RESULT = new StringLit(sleft, sright, s); :}
      | CHAR:c {: RESULT = new CharLit(cleft, cright, c); :}
      | NULL {: RESULT = new NullLit(0, 0); :}
      | FLOAT:f {: RESULT = new FloatLit(fleft, fright, f); :}
      | ID:i {: RESULT = new Var(ileft, iright, i); :}
;